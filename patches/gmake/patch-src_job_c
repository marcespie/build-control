Index: src/job.c
--- src/job.c.orig
+++ src/job.c
@@ -18,7 +18,16 @@ this program.  If not, see <https://www.gnu.org/licens
 
 #include <assert.h>
 #include <string.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/poll.h>
+#include <unistd.h>
+#include <netdb.h>
 
+/* to adjust the number of jobs dynamically */
+static int control_point = -1;
+struct pollfd pollarray[1];
+static void may_adjust_jobs_goal(void);
 #include "job.h"
 #include "debug.h"
 #include "filedef.h"
@@ -1830,9 +1839,13 @@ new_job (struct file *file)
   /* Wait for a job slot to be freed up.  If we allow an infinite number
      don't bother; also job_slots will == 0 if we're using the jobserver.  */
 
-  if (job_slots != 0)
-    while (job_slots_used == job_slots)
+  if (job_slots != 0) {
+    while (job_slots_used >= job_slots) {
+      if (control_point != -1)
+	may_adjust_jobs_goal();
       reap_children (1, 0);
+    }
+  }
 
 #ifdef MAKE_JOBSERVER
   /* If we are controlling multiple jobs make sure we have a token before
@@ -1959,7 +1972,7 @@ new_job (struct file *file)
      (This will notice if there is in fact no recipe.)  */
   start_waiting_job (c);
 
-  if (job_slots == 1 || not_parallel)
+  if (not_parallel)
     /* Since there is only one job slot, make things run linearly.
        Wait for the child to die, setting the state to 'cs_finished'.  */
     while (file->command_state == cs_running)
@@ -3826,3 +3839,151 @@ dup2 (int old, int new)
 #ifdef VMS
 #include "vmsjobs.c"
 #endif
+
+
+
+/* Job control protocol: if the right environment variables are defined,
+ * the actual number of parallel jobs may be adjusted from outside.
+ */
+static void
+may_adjust_jobs_goal()
+{
+	char buffer[1024];
+	int filled = 0;
+	ssize_t n;
+	int p;
+	long value;
+	char *end;
+	int timeout;
+
+	/* since the messages are rather short, we assume a full 
+	 * message will always make it through.
+	 */
+	while ((p = poll(pollarray, 1, 0)) == 1) {
+		if (pollarray[0].revents & POLLHUP) {
+			/* either the server went belly up or we didn't
+			 * identify properly */
+			goto error;
+		} else {
+			/* this is a bit tricky: we may have slept a 
+			 * long time, so there may be several events 
+			 * waiting for us -> keep polling/parsing job 
+			 * number lines. */
+			n = read(control_point, buffer+filled, 
+			    sizeof buffer-1-filled);
+			if (n == -1)
+				goto error;
+			filled += n;
+			buffer[filled] = 0;
+			while (filled > 0) {
+				value = strtol(buffer, &end, 10);
+				if (value < 0)
+					goto error;
+				if (*end == 0)
+					break; /* no full line */
+				/* skips thru terminators */
+				while (*end == '\r' || *end == '\n')
+					end++;
+				/* adjust goals temporarily */
+				job_slots = value;
+				/* and go for another round */
+				memmove(buffer, end, 
+				    sizeof buffer - (end-buffer));
+				filled -= (end-buffer);
+			}
+		}
+error:
+		close(control_point);
+		control_point = -1;
+		break;
+	}
+}
+
+/* various types of socket: if anything goes wrong, we just don't connect
+ * and we won't be able to adjust anything
+ */
+static int
+connect_to_local_addr(const char *name)
+{
+	struct sockaddr_un addr;
+	int s;
+
+	addr.sun_len = sizeof(addr);
+	addr.sun_family = AF_UNIX;
+	strlcpy(addr.sun_path, name, sizeof(addr.sun_path));
+
+	s = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (s == -1) {
+		return -1;
+	}
+	if (connect(s, (const struct sockaddr *)&addr, sizeof(addr)) == -1) {
+		close(s);
+		return -1;
+    	}
+	return s;
+}
+
+static int
+connect_to_inet(const char *server, const char *service)
+{
+	struct addrinfo hints, *res, *res0;
+	int error;
+	int s;
+
+	memset(&hints, 0, sizeof hints);
+	hints.ai_family = AF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+
+	error = getaddrinfo(server, service, &hints, &res0);
+	if (error)
+		return -1;
+
+	for (res = res0; res; res = res->ai_next) {
+		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+		if (s == -1)
+			continue;
+		if (connect(s, res->ai_addr, res->ai_addrlen) == -1) {
+			close(s);
+			s = -1;
+			continue;
+		}
+		break;
+	}
+	return s;
+}
+
+static int
+connect_to(char *addr)
+{
+	char *pos;
+
+	if (strchr(addr, '/')) {
+		return connect_to_local_addr(addr);
+	} else if ((pos = strchr(addr, ':')) != NULL) {
+		*pos = 0;
+		return connect_to_inet(addr, pos+1);
+	} else {
+		return connect_to_inet(addr, NULL);
+	}
+}
+
+void
+may_connect_to_controller(void)
+{
+	char *addr = getenv("BUILDSOCKET");
+	char *token = getenv("BUILDTOKEN");
+	if (addr != NULL && strcmp(addr, "") != 0
+	    && token != NULL && strcmp(token, "") != 0) {
+		control_point = connect_to(addr);
+		if (control_point != -1) {
+			/* if we managed to connect, identify ourselves
+			 * to the builder.
+			 */
+			write(control_point, token, strlen(token));
+			/* Follow the full protocol, make it a full line */
+			write(control_point, "\r\n", 2);
+			pollarray[0].fd = control_point;
+			pollarray[0].events = POLLIN | POLLHUP;
+		}
+	}
+}
