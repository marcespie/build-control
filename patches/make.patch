Index: engine.c
===================================================================
RCS file: /build/data/openbsd/cvs/src/usr.bin/make/engine.c,v
diff -u -p -r1.74 engine.c
--- engine.c	9 Apr 2024 15:08:21 -0000	1.74
+++ engine.c	22 Jan 2025 18:04:22 -0000
@@ -579,8 +579,6 @@ handle_job_status(Job *job, int status)
 			 * JOB_IS_EXPENSIVE, perform the computation for
 			 * sequential make to figure out whether to display the
 			 * command or not.  */
-			if ((job->flags & JOB_SILENT) && sequential)
-				determine_expensive_job(job);
 			if ((job->flags & (JOB_SILENT | JOB_IS_EXPENSIVE)) 
 			    == JOB_SILENT)
 				printf(": %s", job->cmd);
Index: job.c
===================================================================
RCS file: /build/data/openbsd/cvs/src/usr.bin/make/job.c,v
diff -u -p -r1.166 job.c
--- job.c	18 Jun 2024 02:11:03 -0000	1.166
+++ job.c	22 Jan 2025 22:20:12 -0000
@@ -93,6 +93,10 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/poll.h>
+#include <netdb.h>
 #include "defines.h"
 #include "job.h"
 #include "engine.h"
@@ -115,7 +119,6 @@ static int	aborting = 0;	    /* why is t
 static bool	no_new_jobs;	/* Mark recursive shit so we shouldn't start
 				 * something else at the same time
 				 */
-bool sequential;
 Job *runningJobs;		/* Jobs currently running a process */
 Job *errorJobs;			/* Jobs in error at end */
 Job *availableJobs;		/* Pool of available jobs */
@@ -123,6 +126,12 @@ static Job *heldJobs;		/* Jobs not runni
 static pid_t mypid;		/* Used for printing debugging messages */
 static Job *extra_job;		/* Needed for .INTERRUPT */
 
+/* to adjust the number of jobs dynamically */
+static int control_point = -1;
+struct pollfd pollarray[1];
+int jobs_goal;
+int allocated;
+
 static volatile sig_atomic_t got_fatal;
 
 static volatile sig_atomic_t got_SIGINT, got_SIGHUP, got_SIGQUIT, got_SIGTERM, 
@@ -150,6 +159,7 @@ static void debug_vprintf(const char *, 
 static void may_remove_target(Job *);
 static void print_error(Job *);
 static void internal_print_errors(void);
+static void may_adjust_maxjobs(void);
 
 static int dying_signal = 0;
 
@@ -273,6 +283,7 @@ print_error(Job *j)
 	Buf_Destroy(&buf);
 	free(j->cmd);
 }
+
 static void
 quick_summary(int signo)
 {
@@ -540,8 +551,13 @@ postprocess_job(Job *job)
 		job->next = errorJobs;
 		errorJobs = job;
 	} else {
-		job->next = availableJobs;
-		availableJobs = job;
+		if (allocated <= jobs_goal) {
+			job->next = availableJobs;
+			availableJobs = job;
+	    	} else {
+			free(job);
+			allocated--;
+		}
 	}
 
 	if (errorJobs != NULL && aborting != ABORT_INTERRUPT)
@@ -658,7 +674,7 @@ may_continue_job(Job *job)
 		bool finished = job_run_next(job);
 		if (finished)
 			postprocess_job(job);
-		else if (!sequential)
+		else 
 			determine_expensive_job(job);
 	}
 }
@@ -753,6 +769,9 @@ reap_jobs(void)
 	bool reaped = false;
 	Job *job;
 
+	if (control_point != -1) {
+		may_adjust_maxjobs();
+	}
 	while ((pid = waitpid(WAIT_ANY, &status, WNOHANG)) > 0) {
 		if (WIFSTOPPED(status))
 			continue;
@@ -810,6 +829,38 @@ handle_running_jobs(void)
 	reset_signal_mask();
 }
 
+static void
+adjust_up(void)
+{
+	Job *j;
+
+	for (;allocated < jobs_goal; allocated++) {
+		j = emalloc(sizeof(Job));
+		j->next = availableJobs;
+		availableJobs = j;
+	}
+}
+
+
+static void
+may_adjust_maxjobs(void)
+{
+	int n = poll(pollarray, 1, 0);
+	if (n != 1)
+		return;
+	if (pollarray[0].revents & POLLHUP) {
+		close(control_point);
+		control_point = -1;
+		return;
+	} else {
+		char buffer[1024];
+		read(control_point, buffer, sizeof buffer-1);
+		jobs_goal = atoi(buffer);
+	}
+	if (allocated < jobs_goal)
+		adjust_up();
+}
+
 void
 loop_handle_running_jobs(void)
 {
@@ -817,26 +868,102 @@ loop_handle_running_jobs(void)
 		handle_running_jobs();
 }
 
+
+static int
+connect_to_local_addr(const char *name)
+{
+	struct sockaddr_un addr;
+	int s;
+
+	addr.sun_len = sizeof(addr);
+	addr.sun_family = AF_UNIX;
+	strlcpy(addr.sun_path, name, sizeof(addr.sun_path));
+
+	s = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (s == -1) {
+		return -1;
+	}
+	if (connect(s, (const struct sockaddr *)&addr, sizeof(addr)) == -1) {
+		close(s);
+		return -1;
+    	}
+	return s;
+}
+
+static int
+connect_to_inet(const char *server, const char *service)
+{
+	struct addrinfo hints, *res, *res0;
+	int error;
+	int s;
+
+	memset(&hints, 0, sizeof hints);
+	hints.ai_family = AF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+
+	error = getaddrinfo(server, service, &hints, &res0);
+	if (error)
+		Fatal("getaddrinfo: %s", gai_strerror(error));
+
+	for (res = res0; res; res = res->ai_next) {
+		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+		if (s == -1)
+			continue;
+		if (connect(s, res->ai_addr, res->ai_addrlen) == -1) {
+			close(s);
+			s = -1;
+			continue;
+		}
+		break;
+	}
+	return s;
+}
+
+static int
+connect_to(char *addr)
+{
+	char *pos;
+
+	if (strchr(addr, '/')) {
+		return connect_to_local_addr(addr);
+	} else if ((pos = strchr(addr, ':')) != NULL) {
+		*pos = 0;
+		return connect_to_inet(addr, pos+1);
+	} else {
+		return connect_to_inet(addr, NULL);
+	}
+}
+
 void
-Job_Init(int maxJobs)
+may_connect_to_controller(void)
 {
-	Job *j;
-	int i;
+	char *addr = getenv("BUILDCONTROLADDR");
+	char *token = getenv("BUILDTOKEN");
+	if (addr != NULL && strcmp(addr, "") != 0
+	    && token != NULL && strcmp(token, "") != 0) {
+		control_point = connect_to(addr);
+		if (control_point != -1) {
+			write(control_point, token, strlen(token));
+			pollarray[0].fd = control_point;
+			pollarray[0].events = POLLIN | POLLHUP;
+		}
+	}
+}
 
+void
+Job_Init(int maxJobs)
+{
 	runningJobs = NULL;
 	heldJobs = NULL;
 	errorJobs = NULL;
 	availableJobs = NULL;
-	sequential = maxJobs == 1;
+	jobs_goal = maxJobs;
 
+	adjust_up();
 	/* we allocate n+1 jobs, since we may need an extra job for
 	 * running .INTERRUPT.  */
-	j = ereallocarray(NULL, sizeof(Job), maxJobs+1);
-	for (i = 0; i != maxJobs; i++) {
-		j[i].next = availableJobs;
-		availableJobs = &j[i];
-	}
-	extra_job = &j[maxJobs];
+	/* we need the extra_job for running .INTERRUPT */
+	extra_job = emalloc(sizeof(Job));
 	mypid = getpid();
 
 	aborting = 0;
Index: job.h
===================================================================
RCS file: /build/data/openbsd/cvs/src/usr.bin/make/job.h,v
diff -u -p -r1.39 job.h
--- job.h	21 May 2024 05:00:48 -0000	1.39
+++ job.h	22 Jan 2025 22:05:53 -0000
@@ -96,7 +96,6 @@ extern void debug_job_printf(const char 
 extern int check_dying_signal(void);
 
 extern const char *basedirectory;
-
-extern bool	sequential;	/* True if we are running one single-job */
+extern void may_connect_to_controller(void);
 
 #endif /* _JOB_H_ */
Index: main.c
===================================================================
RCS file: /build/data/openbsd/cvs/src/usr.bin/make/main.c,v
diff -u -p -r1.133 main.c
--- main.c	18 Jun 2024 02:11:03 -0000	1.133
+++ main.c	22 Jan 2025 22:06:43 -0000
@@ -706,6 +706,7 @@ main(int argc, char **argv)
 	Var_Set("MACHINE", machine);
 	Var_Set("MACHINE_ARCH", machine_arch);
 	Var_Set("MACHINE_CPU", machine_cpu);
+	may_connect_to_controller();
 
 	/*
 	 * First snag any flags out of the MAKEFLAGS environment variable.
